<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types and Functions · AutoMLPipeline Documentation</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">AutoMLPipeline Documentation</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">HOME</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../../tutorial/pipeline/">Pipeline</a></li><li><a class="tocitem" href="../../tutorial/preprocessing/">Preprocessing</a></li><li><a class="tocitem" href="../../tutorial/learning/">Training and Validation</a></li><li><a class="tocitem" href="../../tutorial/extending/">Extending AutoMLPipeline</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/pipeline/">Pipeline</a></li><li><a class="tocitem" href="../../man/preprocessors/">Preprocessors</a></li><li><a class="tocitem" href="../../man/learners/">Learners</a></li><li><a class="tocitem" href="../../man/metaensembles/">Meta-Ensembles</a></li></ul></li><li><span class="tocitem">Library</span><ul><li class="is-active"><a class="tocitem" href>Types and Functions</a><ul class="internal"><li><a class="tocitem" href="#Index-1"><span>Index</span></a></li><li><a class="tocitem" href="#Descriptions-1"><span>Descriptions</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Types and Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Types and Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/IBM/AutoMLPipeline.jl/blob/master/docs/src/lib/typesfunctions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="lib_decisiontree-1"><a class="docs-heading-anchor" href="#lib_decisiontree-1">Types and Functions</a><a class="docs-heading-anchor-permalink" href="#lib_decisiontree-1" title="Permalink"></a></h1><h2 id="Index-1"><a class="docs-heading-anchor" href="#Index-1">Index</a><a class="docs-heading-anchor-permalink" href="#Index-1" title="Permalink"></a></h2><ul><li><a href="#AutoMLPipeline.AbsTypes.fit!-Tuple{PrunedTree,DataFrames.DataFrame,Array{T,1} where T}"><code>AutoMLPipeline.AbsTypes.fit!</code></a></li><li><a href="#AutoMLPipeline.AbsTypes.fit!-Tuple{Adaboost,DataFrames.DataFrame,Array{T,1} where T}"><code>AutoMLPipeline.AbsTypes.fit!</code></a></li><li><a href="#AutoMLPipeline.AbsTypes.fit!-Tuple{Machine,DataFrames.DataFrame,Array{T,1} where T}"><code>AutoMLPipeline.AbsTypes.fit!</code></a></li><li><a href="#AutoMLPipeline.AbsTypes.fit!-Tuple{RandomForest,DataFrames.DataFrame,Array{T,1} where T}"><code>AutoMLPipeline.AbsTypes.fit!</code></a></li><li><a href="#AutoMLPipeline.AbsTypes.fit!-Tuple{BestLearner,DataFrames.DataFrame,Array{T,1} where T}"><code>AutoMLPipeline.AbsTypes.fit!</code></a></li><li><a href="#AutoMLPipeline.AbsTypes.fit!-Tuple{StackEnsemble,DataFrames.DataFrame,Array{T,1} where T}"><code>AutoMLPipeline.AbsTypes.fit!</code></a></li><li><a href="#AutoMLPipeline.AbsTypes.fit!-Tuple{VoteEnsemble,DataFrames.DataFrame,Array{T,1} where T}"><code>AutoMLPipeline.AbsTypes.fit!</code></a></li><li><a href="#AutoMLPipeline.AbsTypes.fit_transform!"><code>AutoMLPipeline.AbsTypes.fit_transform!</code></a></li><li><a href="#AutoMLPipeline.AbsTypes.transform!-Tuple{RandomForest,DataFrames.DataFrame}"><code>AutoMLPipeline.AbsTypes.transform!</code></a></li><li><a href="#AutoMLPipeline.AbsTypes.transform!-Tuple{BestLearner,DataFrames.DataFrame}"><code>AutoMLPipeline.AbsTypes.transform!</code></a></li><li><a href="#AutoMLPipeline.AbsTypes.transform!-Tuple{StackEnsemble,DataFrames.DataFrame}"><code>AutoMLPipeline.AbsTypes.transform!</code></a></li><li><a href="#AutoMLPipeline.AbsTypes.transform!-Tuple{VoteEnsemble,DataFrames.DataFrame}"><code>AutoMLPipeline.AbsTypes.transform!</code></a></li><li><a href="#AutoMLPipeline.AbsTypes.transform!-Tuple{PrunedTree,DataFrames.DataFrame}"><code>AutoMLPipeline.AbsTypes.transform!</code></a></li><li><a href="#AutoMLPipeline.AbsTypes.transform!-Tuple{Machine,DataFrames.DataFrame}"><code>AutoMLPipeline.AbsTypes.transform!</code></a></li><li><a href="#AutoMLPipeline.AbsTypes.transform!-Tuple{Adaboost,DataFrames.DataFrame}"><code>AutoMLPipeline.AbsTypes.transform!</code></a></li><li><a href="#AutoMLPipeline.Pipelines.ComboPipeline"><code>AutoMLPipeline.Pipelines.ComboPipeline</code></a></li><li><a href="#AutoMLPipeline.Pipelines.Pipeline"><code>AutoMLPipeline.Pipelines.Pipeline</code></a></li><li><a href="#AutoMLPipeline.BaseFilters.Imputer"><code>AutoMLPipeline.BaseFilters.Imputer</code></a></li><li><a href="#AutoMLPipeline.BaseFilters.OneHotEncoder"><code>AutoMLPipeline.BaseFilters.OneHotEncoder</code></a></li><li><a href="#AutoMLPipeline.BaseFilters.Wrapper"><code>AutoMLPipeline.BaseFilters.Wrapper</code></a></li><li><a href="#AutoMLPipeline.BaseFilters.createtransformer"><code>AutoMLPipeline.BaseFilters.createtransformer</code></a></li><li><a href="#AutoMLPipeline.FeatureSelectors.CatFeatureSelector"><code>AutoMLPipeline.FeatureSelectors.CatFeatureSelector</code></a></li><li><a href="#AutoMLPipeline.FeatureSelectors.CatNumDiscriminator"><code>AutoMLPipeline.FeatureSelectors.CatNumDiscriminator</code></a></li><li><a href="#AutoMLPipeline.FeatureSelectors.FeatureSelector"><code>AutoMLPipeline.FeatureSelectors.FeatureSelector</code></a></li><li><a href="#AutoMLPipeline.FeatureSelectors.NumFeatureSelector"><code>AutoMLPipeline.FeatureSelectors.NumFeatureSelector</code></a></li><li><a href="#AutoMLPipeline.EnsembleMethods.BestLearner"><code>AutoMLPipeline.EnsembleMethods.BestLearner</code></a></li><li><a href="#AutoMLPipeline.EnsembleMethods.StackEnsemble"><code>AutoMLPipeline.EnsembleMethods.StackEnsemble</code></a></li><li><a href="#AutoMLPipeline.EnsembleMethods.VoteEnsemble"><code>AutoMLPipeline.EnsembleMethods.VoteEnsemble</code></a></li><li><a href="#AutoMLPipeline.SKPreprocessors.SKPreprocessor"><code>AutoMLPipeline.SKPreprocessors.SKPreprocessor</code></a></li><li><a href="#AutoMLPipeline.SKLearners.SKLearner"><code>AutoMLPipeline.SKLearners.SKLearner</code></a></li><li><a href="#AutoMLPipeline.SKLearners.sklearners-Tuple{}"><code>AutoMLPipeline.SKLearners.sklearners</code></a></li><li><a href="#AutoMLPipeline.DecisionTreeLearners.Adaboost"><code>AutoMLPipeline.DecisionTreeLearners.Adaboost</code></a></li><li><a href="#AutoMLPipeline.DecisionTreeLearners.PrunedTree"><code>AutoMLPipeline.DecisionTreeLearners.PrunedTree</code></a></li><li><a href="#AutoMLPipeline.DecisionTreeLearners.RandomForest"><code>AutoMLPipeline.DecisionTreeLearners.RandomForest</code></a></li><li><a href="#AutoMLPipeline.CrossValidators.crossvalidate"><code>AutoMLPipeline.CrossValidators.crossvalidate</code></a></li><li><a href="#AutoMLPipeline.CrossValidators.crossvalidate"><code>AutoMLPipeline.CrossValidators.crossvalidate</code></a></li><li><a href="#AutoMLPipeline.Utils.aggregatorclskipmissing-Tuple{Function}"><code>AutoMLPipeline.Utils.aggregatorclskipmissing</code></a></li><li><a href="#AutoMLPipeline.Utils.createmachine"><code>AutoMLPipeline.Utils.createmachine</code></a></li><li><a href="#AutoMLPipeline.Utils.find_catnum_columns"><code>AutoMLPipeline.Utils.find_catnum_columns</code></a></li><li><a href="#AutoMLPipeline.Utils.holdout-Tuple{Any,Any}"><code>AutoMLPipeline.Utils.holdout</code></a></li><li><a href="#AutoMLPipeline.Utils.infer_eltype-Tuple{Array{T,1} where T}"><code>AutoMLPipeline.Utils.infer_eltype</code></a></li><li><a href="#AutoMLPipeline.Utils.kfold-Tuple{Any,Any}"><code>AutoMLPipeline.Utils.kfold</code></a></li><li><a href="#AutoMLPipeline.Utils.mergedict-Tuple{Dict,Dict}"><code>AutoMLPipeline.Utils.mergedict</code></a></li><li><a href="#AutoMLPipeline.Utils.nested_dict_merge-Tuple{Dict,Dict}"><code>AutoMLPipeline.Utils.nested_dict_merge</code></a></li><li><a href="#AutoMLPipeline.Utils.nested_dict_set!-Union{Tuple{T}, Tuple{Dict,Array{T,1},Any}} where T"><code>AutoMLPipeline.Utils.nested_dict_set!</code></a></li><li><a href="#AutoMLPipeline.Utils.nested_dict_to_tuples-Tuple{Dict}"><code>AutoMLPipeline.Utils.nested_dict_to_tuples</code></a></li><li><a href="#AutoMLPipeline.Utils.score-Tuple{Symbol,Array{T,1} where T,Array{T,1} where T}"><code>AutoMLPipeline.Utils.score</code></a></li></ul><h2 id="Descriptions-1"><a class="docs-heading-anchor" href="#Descriptions-1">Descriptions</a><a class="docs-heading-anchor-permalink" href="#Descriptions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.AbsTypes.fit!-Tuple{Machine,DataFrames.DataFrame,Array{T,1} where T}" href="#AutoMLPipeline.AbsTypes.fit!-Tuple{Machine,DataFrames.DataFrame,Array{T,1} where T}"><code>AutoMLPipeline.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(mc::Machine, input::DataFrame, output::Vector)</code></pre><p>Generic trait to be overloaded by different subtypes of Machine.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/abstracttypes.jl#L15-L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.AbsTypes.fit_transform!" href="#AutoMLPipeline.AbsTypes.fit_transform!"><code>AutoMLPipeline.AbsTypes.fit_transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">fit_transform!(mc::Machine, input::DataFrame, output::Vector=Vector())</code></pre><p>Dynamic dispatch that calls in sequence <code>fit!</code> and <code>transform!</code> functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/abstracttypes.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.AbsTypes.transform!-Tuple{Machine,DataFrames.DataFrame}" href="#AutoMLPipeline.AbsTypes.transform!-Tuple{Machine,DataFrames.DataFrame}"><code>AutoMLPipeline.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(mc::Machine, input::DataFrame)</code></pre><p>Generic trait to be overloaded by different subtypes of Machine.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/abstracttypes.jl#L25-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.Pipelines.ComboPipeline" href="#AutoMLPipeline.Pipelines.ComboPipeline"><code>AutoMLPipeline.Pipelines.ComboPipeline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ComboPipeline(machs::Vector{T}) where {T&lt;:Machine}</code></pre><p>Feature union pipeline which iteratively calls  <code>fit_transform</code> of each element and concatenate their output into one dataframe.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/pipelines.jl#L96-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.Pipelines.Pipeline" href="#AutoMLPipeline.Pipelines.Pipeline"><code>AutoMLPipeline.Pipelines.Pipeline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Pipeline(machs::Vector{T}) where {T&lt;:Machine}</code></pre><p>Linearpipeline which iteratively calls and passes the result of <code>fit_transform</code> to the succeeding elements in the pipeline. . </p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/pipelines.jl#L14-L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.BaseFilters.OneHotEncoder" href="#AutoMLPipeline.BaseFilters.OneHotEncoder"><code>AutoMLPipeline.BaseFilters.OneHotEncoder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OneHotEncoder(Dict(
   # Nominal columns
   :nominal_columns =&gt; Int[],

   # Nominal column values map. Key is column index, value is list of
   # possible values for that column.
   :nominal_column_values_map =&gt; Dict{Int,Any}()
))</code></pre><p>Transforms instances with nominal features into one-hot form and coerces the instance matrix to be of element type Float64.</p><p>Implements <code>fit!</code> and <code>transform</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/basefilters.jl#L16-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.BaseFilters.Imputer" href="#AutoMLPipeline.BaseFilters.Imputer"><code>AutoMLPipeline.BaseFilters.Imputer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Imputer(
   Dict(
      # Imputation strategy.
      # Statistic that takes a vector such as mean or median.
      :strategy =&gt; mean
   )
)</code></pre><p>Imputes NaN values from Float64 features.</p><p>Implements <code>fit!</code> and <code>transform</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/basefilters.jl#L114-L126">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.BaseFilters.Wrapper" href="#AutoMLPipeline.BaseFilters.Wrapper"><code>AutoMLPipeline.BaseFilters.Wrapper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Wrapper(
   default_args = Dict(
      # Transformer to call.
      :transformer =&gt; OneHotEncoder(),
      # Transformer args.
      :transformer_args =&gt; nothing
   )
)</code></pre><p>Wraps around a AutoMLPipeline transformer.</p><p>Implements <code>fit!</code> and <code>transform</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/basefilters.jl#L167-L180">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.BaseFilters.createtransformer" href="#AutoMLPipeline.BaseFilters.createtransformer"><code>AutoMLPipeline.BaseFilters.createtransformer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">createtransformer(prototype::Transformer, args=Dict())</code></pre><p>Create transformer</p><ul><li><code>prototype</code>: prototype transformer to base new transformer on</li><li><code>options</code>: additional options to override prototype&#39;s options</li></ul><p>Returns: new transformer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/basefilters.jl#L222-L231">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.FeatureSelectors.CatFeatureSelector" href="#AutoMLPipeline.FeatureSelectors.CatFeatureSelector"><code>AutoMLPipeline.FeatureSelectors.CatFeatureSelector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CatFeatureSelector(Dict(:name =&gt; &quot;catfeatsel&quot;))</code></pre><p>Automatically extract categorical columns based on  inferred element types.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/featureselector.jl#L70-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.FeatureSelectors.CatNumDiscriminator" href="#AutoMLPipeline.FeatureSelectors.CatNumDiscriminator"><code>AutoMLPipeline.FeatureSelectors.CatNumDiscriminator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CatNumDiscriminator(
   Dict(
      :name =&gt; &quot;catnumdisc&quot;,
      :maxcategories =&gt; 24
   )
)</code></pre><p>Transform numeric columns to string (as categories)  if the count of their unique elements &lt;= maxcategories.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/featureselector.jl#L161-L173">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.FeatureSelectors.FeatureSelector" href="#AutoMLPipeline.FeatureSelectors.FeatureSelector"><code>AutoMLPipeline.FeatureSelectors.FeatureSelector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">FeatureSelector(
   Dict(
     :name =&gt; &quot;featureselector&quot;,
 :columns =&gt; [col1, col2, ...]
   )
)</code></pre><p>Returns a dataframe of the selected columns.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/featureselector.jl#L17-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.FeatureSelectors.NumFeatureSelector" href="#AutoMLPipeline.FeatureSelectors.NumFeatureSelector"><code>AutoMLPipeline.FeatureSelectors.NumFeatureSelector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">NumFeatureSelector(Dict(:name=&gt;&quot;numfeatsel&quot;))</code></pre><p>Automatically extracts numeric features based on their inferred element types.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/featureselector.jl#L116-L122">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.EnsembleMethods.BestLearner" href="#AutoMLPipeline.EnsembleMethods.BestLearner"><code>AutoMLPipeline.EnsembleMethods.BestLearner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">BestLearner(
   Dict(
      # Output to train against
      # (:class).
      :output =&gt; :class,
      # Function to return partitions of instance indices.
      :partition_generator =&gt; (instances, labels) -&gt; kfold(size(instances, 1), 5),
      # Function that selects the best learner by index.
      # Arg learner_partition_scores is a (learner, partition) score matrix.
      :selection_function =&gt; (learner_partition_scores) -&gt; findmax(mean(learner_partition_scores, dims=2))[2],      
      # Score type returned by score() using respective output.
      :score_type =&gt; Real,
      # Candidate learners.
      :learners =&gt; [PrunedTree(), Adaboost(), RandomForest()],
      # Options grid for learners, to search through by BestLearner.
      # Format is [learner_1_options, learner_2_options, ...]
      # where learner_options is same as a learner&#39;s options but
      # with a list of values instead of scalar.
      :learner_options_grid =&gt; nothing
   )
)</code></pre><p>Selects best learner from the set by performing a  grid search on learners if grid option is indicated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/ensemble.jl#L261-L286">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.EnsembleMethods.StackEnsemble" href="#AutoMLPipeline.EnsembleMethods.StackEnsemble"><code>AutoMLPipeline.EnsembleMethods.StackEnsemble</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">StackEnsemble(
   Dict(    
      # Output to train against
      # (:class).
      :output =&gt; :class,
      # Set of learners that produce feature space for stacker.
      :learners =&gt; [PrunedTree(), Adaboost(), RandomForest()],
      # Machine learner that trains on set of learners&#39; outputs.
      :stacker =&gt; RandomForest(),
      # Proportion of training set left to train stacker itself.
      :stacker_training_proportion =&gt; 0.3,
      # Provide original features on top of learner outputs to stacker.
      :keep_original_features =&gt; false
   )
)</code></pre><p>An ensemble where a &#39;stack&#39; of learners is used for training and prediction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/ensemble.jl#L100-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.EnsembleMethods.VoteEnsemble" href="#AutoMLPipeline.EnsembleMethods.VoteEnsemble"><code>AutoMLPipeline.EnsembleMethods.VoteEnsemble</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VoteEnsemble(
   Dict( 
      # Output to train against
      # (:class).
      :output =&gt; :class,
      # Learners in voting committee.
      :learners =&gt; [PrunedTree(), Adaboost(), RandomForest()]
   )
)</code></pre><p>Set of machine learners employing majority vote to decide prediction.</p><p>Implements: <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/ensemble.jl#L21-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.AbsTypes.fit!-Tuple{BestLearner,DataFrames.DataFrame,Array{T,1} where T}" href="#AutoMLPipeline.AbsTypes.fit!-Tuple{BestLearner,DataFrames.DataFrame,Array{T,1} where T}"><code>AutoMLPipeline.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(bls::BestLearner, instances::DataFrame, labels::Vector)</code></pre><p>Training phase:</p><ul><li>obtain learners as is if grid option is not present </li><li>generate learners if grid option is present </li><li>foreach prototype learner, generate learners with specific options found in grid</li><li>generate partitions</li><li>train each learner on each partition and obtain validation output</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/ensemble.jl#L335-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.AbsTypes.fit!-Tuple{StackEnsemble,DataFrames.DataFrame,Array{T,1} where T}" href="#AutoMLPipeline.AbsTypes.fit!-Tuple{StackEnsemble,DataFrames.DataFrame,Array{T,1} where T}"><code>AutoMLPipeline.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(se::StackEnsemble, instances::DataFrame, labels::Vector)</code></pre><p>Training phase of the stack of learners.</p><ul><li>perform holdout to obtain indices for </li><li>partition learner and stacker training sets</li><li>partition training set for learners and stacker</li><li>train all learners</li><li>train stacker on learners&#39; outputs</li><li>build final model from the trained learners</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/ensemble.jl#L160-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.AbsTypes.fit!-Tuple{VoteEnsemble,DataFrames.DataFrame,Array{T,1} where T}" href="#AutoMLPipeline.AbsTypes.fit!-Tuple{VoteEnsemble,DataFrames.DataFrame,Array{T,1} where T}"><code>AutoMLPipeline.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(ve::VoteEnsemble, instances::DataFrame, labels::Vector)</code></pre><p>Training phase of the ensemble.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/ensemble.jl#L73-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.AbsTypes.transform!-Tuple{BestLearner,DataFrames.DataFrame}" href="#AutoMLPipeline.AbsTypes.transform!-Tuple{BestLearner,DataFrames.DataFrame}"><code>AutoMLPipeline.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(bls::BestLearner, instances::DataFrame)</code></pre><p>Choose the best learner based on cross-validation results and use it for prediction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/ensemble.jl#L426-L431">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.AbsTypes.transform!-Tuple{StackEnsemble,DataFrames.DataFrame}" href="#AutoMLPipeline.AbsTypes.transform!-Tuple{StackEnsemble,DataFrames.DataFrame}"><code>AutoMLPipeline.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(se::StackEnsemble, instances::DataFrame)</code></pre><p>Build stacker instances and predict</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/ensemble.jl#L212-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.AbsTypes.transform!-Tuple{VoteEnsemble,DataFrames.DataFrame}" href="#AutoMLPipeline.AbsTypes.transform!-Tuple{VoteEnsemble,DataFrames.DataFrame}"><code>AutoMLPipeline.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(ve::VoteEnsemble, instances::T) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Prediction phase of the ensemble.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/ensemble.jl#L87-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.SKPreprocessors.SKPreprocessor" href="#AutoMLPipeline.SKPreprocessors.SKPreprocessor"><code>AutoMLPipeline.SKPreprocessors.SKPreprocessor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SKPreprocessor(preprocessor::String,args::Dict=Dict())</code></pre><p>A wrapper for Scikitlearn preprocessor functions.  Invoking <code>skpreprocessors()</code> will list the acceptable  and supported functions. Please check Scikitlearn documentation for arguments to pass.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/skpreprocessor.jl#L90-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.SKLearners.SKLearner" href="#AutoMLPipeline.SKLearners.SKLearner"><code>AutoMLPipeline.SKLearners.SKLearner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SKLearner(learner::String, args::Dict=Dict())</code></pre><p>A Scikitlearn wrapper to load the different machine learning models. Invoking <code>sklearners()</code> will list the available learners. Please consult Scikitlearn documentation for arguments to pass.</p><p>Implements <code>fit!</code> and <code>transform!</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/sklearners.jl#L83-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.SKLearners.sklearners-Tuple{}" href="#AutoMLPipeline.SKLearners.sklearners-Tuple{}"><code>AutoMLPipeline.SKLearners.sklearners</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">sklearners()</code></pre><p>List the available scikitlearn machine learners.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/sklearners.jl#L121-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.DecisionTreeLearners.Adaboost" href="#AutoMLPipeline.DecisionTreeLearners.Adaboost"><code>AutoMLPipeline.DecisionTreeLearners.Adaboost</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Adaboost(
  Dict(
    :output =&gt; :class,
    :num_iterations =&gt; 7
  )
)</code></pre><p>Adaboosted decision tree stumps. See <a href="https://github.com/bensadeghi/DecisionTree.jl">DecisionTree.jl&#39;s documentation</a></p><p>Hyperparameters:</p><ul><li><code>:num_iterations</code> =&gt; 7 (number of iterations of AdaBoost)</li></ul><p>Implements <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/decisiontree.jl#L207-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.DecisionTreeLearners.PrunedTree" href="#AutoMLPipeline.DecisionTreeLearners.PrunedTree"><code>AutoMLPipeline.DecisionTreeLearners.PrunedTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PrunedTree(
  Dict(
    :purity_threshold =&gt; 1.0,
    :max_depth =&gt; -1,
    :min_samples_leaf =&gt; 1,
    :min_samples_split =&gt; 2,
    :min_purity_increase =&gt; 0.0
  )
)</code></pre><p>Decision tree classifier.   See <a href="https://github.com/bensadeghi/DecisionTree.jl">DecisionTree.jl&#39;s documentation</a></p><p>Hyperparmeters:</p><ul><li><code>:purity_threshold</code> =&gt; 1.0 (merge leaves having &gt;=thresh combined purity)</li><li><code>:max_depth</code> =&gt; -1 (maximum depth of the decision tree)</li><li><code>:min_samples_leaf</code> =&gt; 1 (the minimum number of samples each leaf needs to have)</li><li><code>:min_samples_split</code> =&gt; 2 (the minimum number of samples in needed for a split)</li><li><code>:min_purity_increase</code> =&gt; 0.0 (minimum purity needed for a split)</li></ul><p>Implements <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/decisiontree.jl#L20-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.DecisionTreeLearners.RandomForest" href="#AutoMLPipeline.DecisionTreeLearners.RandomForest"><code>AutoMLPipeline.DecisionTreeLearners.RandomForest</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">RandomForest(
  Dict(
    :output =&gt; :class,
    :num_subfeatures =&gt; 0,
    :num_trees =&gt; 10,
    :partial_sampling =&gt; 0.7,
    :max_depth =&gt; -1
  )
)</code></pre><p>Random forest classification.  See <a href="https://github.com/bensadeghi/DecisionTree.jl">DecisionTree.jl&#39;s documentation</a></p><p>Hyperparmeters:</p><ul><li><code>:num_subfeatures</code> =&gt; 0  (number of features to consider at random per split)</li><li><code>:num_trees</code> =&gt; 10 (number of trees to train)</li><li><code>:partial_sampling</code> =&gt; 0.7 (fraction of samples to train each tree on)</li><li><code>:max_depth</code> =&gt; -1 (maximum depth of the decision trees)</li><li><code>:min_samples_leaf</code> =&gt; 1 (the minimum number of samples each leaf needs to have)</li><li><code>:min_samples_split</code> =&gt; 2 (the minimum number of samples in needed for a split)</li><li><code>:min_purity_increase</code> =&gt; 0.0 (minimum purity needed for a split)</li></ul><p>Implements <code>fit!</code>, <code>transform!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/decisiontree.jl#L112-L136">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.AbsTypes.fit!-Tuple{Adaboost,DataFrames.DataFrame,Array{T,1} where T}" href="#AutoMLPipeline.AbsTypes.fit!-Tuple{Adaboost,DataFrames.DataFrame,Array{T,1} where T}"><code>AutoMLPipeline.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(adaboost::Adaboost, features::DataFrame, labels::Vector)</code></pre><p>Optimize the hyperparameters of <code>Adaboost</code> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/decisiontree.jl#L246-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.AbsTypes.fit!-Tuple{PrunedTree,DataFrames.DataFrame,Array{T,1} where T}" href="#AutoMLPipeline.AbsTypes.fit!-Tuple{PrunedTree,DataFrames.DataFrame,Array{T,1} where T}"><code>AutoMLPipeline.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(tree::PrunedTree, features::DataFrame, labels::Vector)</code></pre><p>Optimize the hyperparameters of <code>PrunedTree</code> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/decisiontree.jl#L74-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.AbsTypes.fit!-Tuple{RandomForest,DataFrames.DataFrame,Array{T,1} where T}" href="#AutoMLPipeline.AbsTypes.fit!-Tuple{RandomForest,DataFrames.DataFrame,Array{T,1} where T}"><code>AutoMLPipeline.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">fit!(forest::RandomForest, features::T, labels::Vector) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Optimize the parameters of the <code>RandomForest</code> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/decisiontree.jl#L166-L170">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.AbsTypes.transform!-Tuple{Adaboost,DataFrames.DataFrame}" href="#AutoMLPipeline.AbsTypes.transform!-Tuple{Adaboost,DataFrames.DataFrame}"><code>AutoMLPipeline.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(adaboost::Adaboost, features::T) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Predict using the optimized hyperparameters of the trained <code>Adaboost</code> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/decisiontree.jl#L266-L270">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.AbsTypes.transform!-Tuple{PrunedTree,DataFrames.DataFrame}" href="#AutoMLPipeline.AbsTypes.transform!-Tuple{PrunedTree,DataFrames.DataFrame}"><code>AutoMLPipeline.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(ptree::PrunedTree, features::DataFrame)</code></pre><p>Predict using the optimized hyperparameters of the trained <code>PrunedTree</code> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/decisiontree.jl#L98-L102">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.AbsTypes.transform!-Tuple{RandomForest,DataFrames.DataFrame}" href="#AutoMLPipeline.AbsTypes.transform!-Tuple{RandomForest,DataFrames.DataFrame}"><code>AutoMLPipeline.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">transform!(forest::RandomForest, features::T) where {T&lt;:Union{Vector,Matrix,DataFrame}}</code></pre><p>Predict using the optimized hyperparameters of the trained <code>RandomForest</code> instance.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/decisiontree.jl#L191-L196">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.CrossValidators.crossvalidate" href="#AutoMLPipeline.CrossValidators.crossvalidate"><code>AutoMLPipeline.CrossValidators.crossvalidate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">crossvalidate(pl::Machine,X::DataFrame,Y::Vector,sfunc::String=&quot;balanced_accuracy_score&quot;,nfolds=10)</code></pre><p>Runs K-fold cross-validation using balanced accuracy as the default. It support the  following metric:</p><ul><li>accuracy_score</li><li>balanced<em>accuracy</em>score</li><li>cohen<em>kappa</em>score</li><li>jaccard_score</li><li>matthews_corrcoef</li><li>hamming_loss</li><li>zero<em>one</em>loss</li><li>f1_score</li><li>precision_score</li><li>recall_score</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/skcrossvalidator.jl#L52-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.CrossValidators.crossvalidate" href="#AutoMLPipeline.CrossValidators.crossvalidate"><code>AutoMLPipeline.CrossValidators.crossvalidate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">crossvalidate(pl::Machine,X::DataFrame,Y::Vector,pfunc::Function,kfolds=10)</code></pre><p>Run K-fold crossvalidation where:</p><ul><li><code>pfunc</code> is a performance metric</li><li><code>X</code> and <code>Y</code> are input and target </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/crossvalidator.jl#L20-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.Utils.aggregatorclskipmissing-Tuple{Function}" href="#AutoMLPipeline.Utils.aggregatorclskipmissing-Tuple{Function}"><code>AutoMLPipeline.Utils.aggregatorclskipmissing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">aggregatorclskipmissing(fn::Function)</code></pre><p>Function to create aggregator closure with skipmissing features</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/utils.jl#L248-L252">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.Utils.createmachine" href="#AutoMLPipeline.Utils.createmachine"><code>AutoMLPipeline.Utils.createmachine</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">createmachine(prototype::Machine, options=nothing)</code></pre><p>Create machine</p><ul><li><code>prototype</code>: prototype machine to base new machine on</li><li><code>options</code>: additional options to override prototype&#39;s options</li></ul><p>Returns: new machine</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/utils.jl#L228-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.Utils.find_catnum_columns" href="#AutoMLPipeline.Utils.find_catnum_columns"><code>AutoMLPipeline.Utils.find_catnum_columns</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">find_catnum_columns(instances::DataFrame,maxuniqcat::Int=0)</code></pre><p>Finds all categorial and numerical columns. Categorical columns are those that do not have Real type nor do all their elements correspond to Real. Also, columns with size of unique instances are less than <code>maxuniqcat</code> are considered categorical.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/utils.jl#L21-L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.Utils.holdout-Tuple{Any,Any}" href="#AutoMLPipeline.Utils.holdout-Tuple{Any,Any}"><code>AutoMLPipeline.Utils.holdout</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">holdout(n, right_prop)</code></pre><p>Holdout method that partitions a collection into two partitions.</p><ul><li><code>n</code>: Size of collection to partition</li><li><code>right_prop</code>: Percentage of collection placed in right partition</li></ul><p>Returns: two partitions of indices, left and right</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/utils.jl#L49-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.Utils.infer_eltype-Tuple{Array{T,1} where T}" href="#AutoMLPipeline.Utils.infer_eltype-Tuple{Array{T,1} where T}"><code>AutoMLPipeline.Utils.infer_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">infer_eltype(vector::Vector)</code></pre><p>Returns element type of vector unless it is Any. If Any, returns the most specific type that can be inferred from the vector elements.</p><ul><li><code>vector</code>: vector to infer element type on</li></ul><p>Returns: inferred element type</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/utils.jl#L104-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.Utils.kfold-Tuple{Any,Any}" href="#AutoMLPipeline.Utils.kfold-Tuple{Any,Any}"><code>AutoMLPipeline.Utils.kfold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">kfold(num_instances, num_partitions)</code></pre><p>Returns k-fold partitions.</p><ul><li><code>num_instances</code>: total number of instances</li><li><code>num_partitions</code>: number of partitions required</li></ul><p>Returns: training set partition.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/utils.jl#L68-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.Utils.mergedict-Tuple{Dict,Dict}" href="#AutoMLPipeline.Utils.mergedict-Tuple{Dict,Dict}"><code>AutoMLPipeline.Utils.mergedict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mergedict(first::Dict, second::Dict)</code></pre><p>Second nested dictionary is merged into first.</p><p>If a second dictionary&#39;s value as well as the first are both dictionaries, then a merge is conducted between the two inner dictionaries. Otherwise the second&#39;s value overrides the first.</p><ul><li><code>first</code>: first nested dictionary</li><li><code>second</code>: second nested dictionary</li></ul><p>Returns: merged nested dictionary</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/utils.jl#L290-L304">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.Utils.nested_dict_merge-Tuple{Dict,Dict}" href="#AutoMLPipeline.Utils.nested_dict_merge-Tuple{Dict,Dict}"><code>AutoMLPipeline.Utils.nested_dict_merge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nested_dict_merge(first::Dict, second::Dict)</code></pre><p>Second nested dictionary is merged into first.</p><p>If a second dictionary&#39;s value as well as the first are both dictionaries, then a merge is conducted between the two inner dictionaries. Otherwise the second&#39;s value overrides the first.</p><ul><li><code>first</code>: first nested dictionary</li><li><code>second</code>: second nested dictionary</li></ul><p>Returns: merged nested dictionary</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/utils.jl#L198-L212">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.Utils.nested_dict_set!-Union{Tuple{T}, Tuple{Dict,Array{T,1},Any}} where T" href="#AutoMLPipeline.Utils.nested_dict_set!-Union{Tuple{T}, Tuple{Dict,Array{T,1},Any}} where T"><code>AutoMLPipeline.Utils.nested_dict_set!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nested_dict_set!(dict::Dict, keys::Array{T, 1}, value) where {T}</code></pre><p>Set value in a nested dictionary.</p><ul><li><code>dict</code>: nested dictionary to assign value</li><li><code>keys</code>: keys to access nested dictionaries in sequence</li><li><code>value</code>: value to assign</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/utils.jl#L181-L189">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.Utils.nested_dict_to_tuples-Tuple{Dict}" href="#AutoMLPipeline.Utils.nested_dict_to_tuples-Tuple{Dict}"><code>AutoMLPipeline.Utils.nested_dict_to_tuples</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">nested_dict_to_tuples(dict::Dict)</code></pre><p>Converts nested dictionary to list of tuples</p><ul><li><code>dict</code>: dictionary that can have other dictionaries as values</li></ul><p>Returns: list where elements are ([outer-key, inner-key, ...], value)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/utils.jl#L155-L163">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.Utils.score-Tuple{Symbol,Array{T,1} where T,Array{T,1} where T}" href="#AutoMLPipeline.Utils.score-Tuple{Symbol,Array{T,1} where T,Array{T,1} where T}"><code>AutoMLPipeline.Utils.score</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">score(metric::Symbol, actual::Vector, predicted::Vector)</code></pre><p>Score learner predictions against ground truth values.</p><p>Available metrics:</p><ul><li><p>:accuracy</p></li><li><p><code>metric</code>: metric to assess with</p></li><li><p><code>actual</code>: ground truth values</p></li><li><p><code>predicted</code>: predicted values</p></li></ul><p>Returns: score of learner</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/5f89b676ef722f9dedbe3b433c73707774d81655/src/utils.jl#L82-L95">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/metaensembles/">« Meta-Ensembles</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 6 March 2020 21:34">Friday 6 March 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
