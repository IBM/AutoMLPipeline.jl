<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types and Functions · AutoMLPipeline Documentation</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">AutoMLPipeline Documentation</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">HOME</a></li><li><span class="tocitem">Tutorial</span><ul><li><a class="tocitem" href="../../tutorial/pipeline/">Pipeline</a></li><li><a class="tocitem" href="../../tutorial/preprocessing/">Preprocessing</a></li><li><a class="tocitem" href="../../tutorial/learning/">Training and Validation</a></li><li><a class="tocitem" href="../../tutorial/extending/">Extending AutoMLPipeline</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/pipeline/">Pipeline</a></li><li><a class="tocitem" href="../../man/preprocessors/">Preprocessors</a></li><li><a class="tocitem" href="../../man/learners/">Learners</a></li><li><a class="tocitem" href="../../man/metaensembles/">Meta-Ensembles</a></li></ul></li><li><span class="tocitem">Library</span><ul><li class="is-active"><a class="tocitem" href>Types and Functions</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Descriptions"><span>Descriptions</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Library</a></li><li class="is-active"><a href>Types and Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Types and Functions</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/IBM/AutoMLPipeline.jl/blob/master/docs/src/lib/typesfunctions.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="#AMLPipelineBase.AbsTypes.fit!-Tuple{PrunedTree, DataFrames.DataFrame, Vector{T} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a></li><li><a href="#AMLPipelineBase.AbsTypes.fit!-Tuple{RandomForest, DataFrames.DataFrame, Vector{T} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a></li><li><a href="#AMLPipelineBase.AbsTypes.fit!-Tuple{VoteEnsemble, DataFrames.DataFrame, Vector{T} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a></li><li><a href="#AMLPipelineBase.AbsTypes.fit!-Tuple{StackEnsemble, DataFrames.DataFrame, Vector{T} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a></li><li><a href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a></li><li><a href="#AMLPipelineBase.AbsTypes.fit!-Tuple{BestLearner, DataFrames.DataFrame, Vector{T} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a></li><li><a href="#AMLPipelineBase.AbsTypes.fit!-Tuple{Machine, DataFrames.DataFrame, Vector{T} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a></li><li><a href="#AMLPipelineBase.AbsTypes.fit!-Tuple{Adaboost, DataFrames.DataFrame, Vector{T} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a></li><li><a href="#AMLPipelineBase.AbsTypes.fit!-Tuple{Baseline, DataFrames.DataFrame, Vector{T} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a></li><li><a href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a></li><li><a href="#AMLPipelineBase.AbsTypes.fit_transform!"><code>AMLPipelineBase.AbsTypes.fit_transform!</code></a></li><li><a href="#AMLPipelineBase.AbsTypes.transform!-Tuple{Machine, DataFrames.DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a></li><li><a href="#AMLPipelineBase.AbsTypes.transform!-Tuple{Baseline, DataFrames.DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a></li><li><a href="#AMLPipelineBase.AbsTypes.transform!-Tuple{VoteEnsemble, DataFrames.DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a></li><li><a href="#AMLPipelineBase.AbsTypes.transform!-Tuple{PrunedTree, DataFrames.DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a></li><li><a href="#AMLPipelineBase.AbsTypes.transform!-Tuple{Adaboost, DataFrames.DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a></li><li><a href="#AMLPipelineBase.AbsTypes.transform!-Tuple{StackEnsemble, DataFrames.DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a></li><li><a href="#AMLPipelineBase.AbsTypes.transform!-Tuple{NARemover, DataFrames.DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a></li><li><a href="#AMLPipelineBase.AbsTypes.transform!-Tuple{RandomForest, DataFrames.DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a></li><li><a href="#AMLPipelineBase.AbsTypes.transform!"><code>AMLPipelineBase.AbsTypes.transform!</code></a></li><li><a href="#AMLPipelineBase.AbsTypes.transform!-Tuple{BestLearner, DataFrames.DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a></li><li><a href="#AMLPipelineBase.BaselineModels.Baseline-Tuple{String}"><code>AMLPipelineBase.BaselineModels.Baseline</code></a></li><li><a href="#AMLPipelineBase.BaselineModels.Baseline"><code>AMLPipelineBase.BaselineModels.Baseline</code></a></li><li><a href="#AMLPipelineBase.BaselineModels.Identity"><code>AMLPipelineBase.BaselineModels.Identity</code></a></li><li><a href="#AMLPipelineBase.BaselineModels.Identity-Tuple{String}"><code>AMLPipelineBase.BaselineModels.Identity</code></a></li><li><a href="#AMLPipelineBase.BaseFilters.Imputer"><code>AMLPipelineBase.BaseFilters.Imputer</code></a></li><li><a href="#AMLPipelineBase.BaseFilters.OneHotEncoder"><code>AMLPipelineBase.BaseFilters.OneHotEncoder</code></a></li><li><a href="#AMLPipelineBase.BaseFilters.Wrapper"><code>AMLPipelineBase.BaseFilters.Wrapper</code></a></li><li><a href="#AMLPipelineBase.BaseFilters.createtransformer"><code>AMLPipelineBase.BaseFilters.createtransformer</code></a></li><li><a href="#AMLPipelineBase.Pipelines.ComboPipeline"><code>AMLPipelineBase.Pipelines.ComboPipeline</code></a></li><li><a href="#AMLPipelineBase.Pipelines.Pipeline-Tuple{Vector{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Machine, Dict}"><code>AMLPipelineBase.Pipelines.Pipeline</code></a></li><li><a href="#AMLPipelineBase.Pipelines.Pipeline-Tuple{Vararg{Machine, N} where N}"><code>AMLPipelineBase.Pipelines.Pipeline</code></a></li><li><a href="#AMLPipelineBase.Pipelines.Pipeline"><code>AMLPipelineBase.Pipelines.Pipeline</code></a></li><li><a href="#AMLPipelineBase.NARemovers.NARemover-Tuple{Float64}"><code>AMLPipelineBase.NARemovers.NARemover</code></a></li><li><a href="#AMLPipelineBase.NARemovers.NARemover"><code>AMLPipelineBase.NARemovers.NARemover</code></a></li><li><a href="#AMLPipelineBase.CrossValidators.crossvalidate-Tuple{Machine, DataFrames.DataFrame, Vector{T} where T, Function, Int64, Bool}"><code>AMLPipelineBase.CrossValidators.crossvalidate</code></a></li><li><a href="#AMLPipelineBase.CrossValidators.crossvalidate-Tuple{Machine, DataFrames.DataFrame, Vector{T} where T, String}"><code>AMLPipelineBase.CrossValidators.crossvalidate</code></a></li><li><a href="#AMLPipelineBase.DecisionTreeLearners.Adaboost"><code>AMLPipelineBase.DecisionTreeLearners.Adaboost</code></a></li><li><a href="#AMLPipelineBase.DecisionTreeLearners.PrunedTree"><code>AMLPipelineBase.DecisionTreeLearners.PrunedTree</code></a></li><li><a href="#AMLPipelineBase.DecisionTreeLearners.RandomForest"><code>AMLPipelineBase.DecisionTreeLearners.RandomForest</code></a></li><li><a href="#AMLPipelineBase.EnsembleMethods.BestLearner"><code>AMLPipelineBase.EnsembleMethods.BestLearner</code></a></li><li><a href="#AMLPipelineBase.EnsembleMethods.StackEnsemble"><code>AMLPipelineBase.EnsembleMethods.StackEnsemble</code></a></li><li><a href="#AMLPipelineBase.EnsembleMethods.VoteEnsemble"><code>AMLPipelineBase.EnsembleMethods.VoteEnsemble</code></a></li><li><a href="#AMLPipelineBase.FeatureSelectors.CatFeatureSelector"><code>AMLPipelineBase.FeatureSelectors.CatFeatureSelector</code></a></li><li><a href="#AMLPipelineBase.FeatureSelectors.CatNumDiscriminator-Tuple{Int64}"><code>AMLPipelineBase.FeatureSelectors.CatNumDiscriminator</code></a></li><li><a href="#AMLPipelineBase.FeatureSelectors.CatNumDiscriminator"><code>AMLPipelineBase.FeatureSelectors.CatNumDiscriminator</code></a></li><li><a href="#AMLPipelineBase.FeatureSelectors.FeatureSelector"><code>AMLPipelineBase.FeatureSelectors.FeatureSelector</code></a></li><li><a href="#AMLPipelineBase.FeatureSelectors.FeatureSelector-Tuple{Vector{Int64}}"><code>AMLPipelineBase.FeatureSelectors.FeatureSelector</code></a></li><li><a href="#AMLPipelineBase.FeatureSelectors.FeatureSelector-Tuple{Vararg{Int64, N} where N}"><code>AMLPipelineBase.FeatureSelectors.FeatureSelector</code></a></li><li><a href="#AMLPipelineBase.FeatureSelectors.NumFeatureSelector"><code>AMLPipelineBase.FeatureSelectors.NumFeatureSelector</code></a></li><li><a href="#AutoMLPipeline.SKLearners.SKLearner"><code>AutoMLPipeline.SKLearners.SKLearner</code></a></li><li><a href="#AutoMLPipeline.SKLearners.sklearners-Tuple{}"><code>AutoMLPipeline.SKLearners.sklearners</code></a></li><li><a href="#AutoMLPipeline.SKPreprocessors.SKPreprocessor"><code>AutoMLPipeline.SKPreprocessors.SKPreprocessor</code></a></li><li><a href="#AMLPipelineBase.Utils.aggregatorclskipmissing-Tuple{Function}"><code>AMLPipelineBase.Utils.aggregatorclskipmissing</code></a></li><li><a href="#AMLPipelineBase.Utils.createmachine"><code>AMLPipelineBase.Utils.createmachine</code></a></li><li><a href="#AMLPipelineBase.Utils.find_catnum_columns"><code>AMLPipelineBase.Utils.find_catnum_columns</code></a></li><li><a href="#AMLPipelineBase.Utils.holdout-Tuple{Any, Any}"><code>AMLPipelineBase.Utils.holdout</code></a></li><li><a href="#AMLPipelineBase.Utils.infer_eltype-Tuple{Vector{T} where T}"><code>AMLPipelineBase.Utils.infer_eltype</code></a></li><li><a href="#AMLPipelineBase.Utils.kfold-Tuple{Any, Any}"><code>AMLPipelineBase.Utils.kfold</code></a></li><li><a href="#AMLPipelineBase.Utils.nested_dict_merge-Tuple{Dict, Dict}"><code>AMLPipelineBase.Utils.nested_dict_merge</code></a></li><li><a href="#AMLPipelineBase.Utils.nested_dict_set!-Union{Tuple{T}, Tuple{Dict, Vector{T}, Any}} where T"><code>AMLPipelineBase.Utils.nested_dict_set!</code></a></li><li><a href="#AMLPipelineBase.Utils.nested_dict_to_tuples-Tuple{Dict}"><code>AMLPipelineBase.Utils.nested_dict_to_tuples</code></a></li><li><a href="#AMLPipelineBase.Utils.score-Tuple{Symbol, Vector{T} where T, Vector{T} where T}"><code>AMLPipelineBase.Utils.score</code></a></li></ul><h2 id="Descriptions"><a class="docs-heading-anchor" href="#Descriptions">Descriptions</a><a id="Descriptions-1"></a><a class="docs-heading-anchor-permalink" href="#Descriptions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!-Tuple{Machine, DataFrames.DataFrame, Vector{T} where T}" href="#AMLPipelineBase.AbsTypes.fit!-Tuple{Machine, DataFrames.DataFrame, Vector{T} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>fit!(mc::Machine, input::DataFrame, output::Vector)</p><p>Generic trait to be overloaded by different subtypes of Machine. Multiple dispatch for fit!.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit_transform!" href="#AMLPipelineBase.AbsTypes.fit_transform!"><code>AMLPipelineBase.AbsTypes.fit_transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>fit_transform!(mc::Machine, input::DataFrame, output::Vector)</p><p>Dynamic dispatch that calls in sequence <code>fit!</code> and <code>transform!</code> functions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{Machine, DataFrames.DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{Machine, DataFrames.DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><p>transform!(mc::Machine, input::DataFrame)</p><p>Generic trait to be overloaded by different subtypes of Machine. Multiple dispatch for transform!.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaselineModels.Baseline" href="#AMLPipelineBase.BaselineModels.Baseline"><code>AMLPipelineBase.BaselineModels.Baseline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Baseline(
   default_args = Dict(
       :name =&gt; &quot;baseline&quot;,
      :output =&gt; :class,
      :strat =&gt; mode
   )
)</code></pre><p>Baseline model that returns the mode during classification.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaselineModels.Baseline-Tuple{String}" href="#AMLPipelineBase.BaselineModels.Baseline-Tuple{String}"><code>AMLPipelineBase.BaselineModels.Baseline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Baseline(name::String,opt...)</code></pre><p>Helper function</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaselineModels.Identity" href="#AMLPipelineBase.BaselineModels.Identity"><code>AMLPipelineBase.BaselineModels.Identity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Identity(args=Dict())</code></pre><p>Returns the input as output.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaselineModels.Identity-Tuple{String}" href="#AMLPipelineBase.BaselineModels.Identity-Tuple{String}"><code>AMLPipelineBase.BaselineModels.Identity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Identity(name::String,opt...)</code></pre><p>Helper function</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit!(idy::Identity,x::DataFrame,y::Vector)</code></pre><p>Does nothing.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!-Tuple{Baseline, DataFrames.DataFrame, Vector{T} where T}" href="#AMLPipelineBase.AbsTypes.fit!-Tuple{Baseline, DataFrames.DataFrame, Vector{T} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(bsl::Baseline,x::DataFrame,y::Vector)</code></pre><p>Get the mode of the training data.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!" href="#AMLPipelineBase.AbsTypes.transform!"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">transform!(idy::Identity,x::DataFrame)</code></pre><p>Return the input as output.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{Baseline, DataFrames.DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{Baseline, DataFrames.DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(bsl::Baseline,x::DataFrame)</code></pre><p>Return the mode in classification.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaseFilters.Imputer" href="#AMLPipelineBase.BaseFilters.Imputer"><code>AMLPipelineBase.BaseFilters.Imputer</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Imputer(
   Dict(
      # Imputation strategy.
      # Statistic that takes a vector such as mean or median.
      :strategy =&gt; mean
   )
)</code></pre><p>Imputes NaN values from Float64 features.</p><p>Implements <code>fit!</code> and <code>transform</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaseFilters.OneHotEncoder" href="#AMLPipelineBase.BaseFilters.OneHotEncoder"><code>AMLPipelineBase.BaseFilters.OneHotEncoder</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">OneHotEncoder(Dict(
   # Nominal columns
   :nominal_columns =&gt; Int[],

   # Nominal column values map. Key is column index, value is list of
   # possible values for that column.
   :nominal_column_values_map =&gt; Dict{Int,Any}()
))</code></pre><p>Transforms myinstances with nominal features into one-hot form and coerces the instance matrix to be of element type Float64.</p><p>Implements <code>fit!</code> and <code>transform</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaseFilters.Wrapper" href="#AMLPipelineBase.BaseFilters.Wrapper"><code>AMLPipelineBase.BaseFilters.Wrapper</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Wrapper(
   default_args = Dict(
      :name =&gt; &quot;ohe-wrapper&quot;,
      # Transformer to call.
      :transformer =&gt; OneHotEncoder(),
      # Transformer args.
      :transformer_args =&gt; Dict()
   )
)</code></pre><p>Wraps around a transformer.</p><p>Implements <code>fit!</code> and <code>transform</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.BaseFilters.createtransformer" href="#AMLPipelineBase.BaseFilters.createtransformer"><code>AMLPipelineBase.BaseFilters.createtransformer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">createtransformer(prototype::Transformer, args=Dict())</code></pre><p>Create transformer</p><ul><li><code>prototype</code>: prototype transformer to base new transformer on</li><li><code>options</code>: additional options to override prototype&#39;s options</li></ul><p>Returns: new transformer.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.Pipelines.ComboPipeline" href="#AMLPipelineBase.Pipelines.ComboPipeline"><code>AMLPipelineBase.Pipelines.ComboPipeline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ComboPipeline(machs::Vector{T}) where {T&lt;:Machine}</code></pre><p>Feature union pipeline which iteratively calls  <code>fit_transform</code> of each element and concatenate their output into one dataframe.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.Pipelines.Pipeline" href="#AMLPipelineBase.Pipelines.Pipeline"><code>AMLPipelineBase.Pipelines.Pipeline</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Pipeline(machs::Vector{&lt;:Machine},args::Dict=Dict())</code></pre><p>Linear pipeline which iteratively calls and passes the result of <code>fit_transform</code> to the succeeding elements in the pipeline.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.Pipelines.Pipeline-Tuple{Vararg{Machine, N} where N}" href="#AMLPipelineBase.Pipelines.Pipeline-Tuple{Vararg{Machine, N} where N}"><code>AMLPipelineBase.Pipelines.Pipeline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Pipeline(machs::Vararg{Machine})</code></pre><p>Helper function for Pipeline structure.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.Pipelines.Pipeline-Tuple{Vector{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Machine, Dict}" href="#AMLPipelineBase.Pipelines.Pipeline-Tuple{Vector{var&quot;#s9&quot;} where var&quot;#s9&quot;&lt;:Machine, Dict}"><code>AMLPipelineBase.Pipelines.Pipeline</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Pipeline(machs::Vector{&lt;:Machine},args::Dict=Dict())</code></pre><p>Helper function for Pipeline structure.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.NARemovers.NARemover" href="#AMLPipelineBase.NARemovers.NARemover"><code>AMLPipelineBase.NARemovers.NARemover</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NARemover(
  Dict(
    :name =&gt; &quot;nadetect&quot;,
    :acceptance =&gt; 0.10 # tolerable NAs percentage
  )
)</code></pre><p>Removes columns with NAs greater than acceptance rate. This assumes that it processes columns of features.  The output column should not be part of input to avoid it being excluded if it fails the acceptance critera.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.NARemovers.NARemover-Tuple{Float64}" href="#AMLPipelineBase.NARemovers.NARemover-Tuple{Float64}"><code>AMLPipelineBase.NARemovers.NARemover</code></a> — <span class="docstring-category">Method</span></header><section><div><p>NARemover(acceptance::Float64)</p><p>Helper function for NARemover.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!" href="#AMLPipelineBase.AbsTypes.fit!"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">fit!(nad::NARemover,features::DataFrame,labels::Vector=[])</code></pre><p>Checks and exit of df is empty</p><p><strong>Arguments</strong></p><ul><li><code>nad::NARemover</code>: custom type</li><li><code>features::DataFrame</code>: input</li><li><code>labels::Vector=[]</code>: </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{NARemover, DataFrames.DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{NARemover, DataFrames.DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(nad::NARemover,nfeatures::DataFrame)</code></pre><p>Removes columns with NAs greater than acceptance rate.</p><p><strong>Arguments</strong></p><ul><li><code>nad::NARemover</code>: custom type</li><li><code>nfeatures::DataFrame</code>: input</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.CrossValidators.crossvalidate-Tuple{Machine, DataFrames.DataFrame, Vector{T} where T, Function, Int64, Bool}" href="#AMLPipelineBase.CrossValidators.crossvalidate-Tuple{Machine, DataFrames.DataFrame, Vector{T} where T, Function, Int64, Bool}"><code>AMLPipelineBase.CrossValidators.crossvalidate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">crossvalidate(pl::Machine,X::DataFrame,Y::Vector,pfunc::Function,kfolds=10)</code></pre><p>Run K-fold crossvalidation where:</p><ul><li><code>pfunc</code> is a performance metric</li><li><code>X</code> and <code>Y</code> are input and target </li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.DecisionTreeLearners.Adaboost" href="#AMLPipelineBase.DecisionTreeLearners.Adaboost"><code>AMLPipelineBase.DecisionTreeLearners.Adaboost</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Adaboost(
  Dict(
    :output =&gt; :class,
    :num_iterations =&gt; 7
  )
)</code></pre><p>Adaboosted decision tree stumps. See <a href="https://github.com/bensadeghi/DecisionTree.jl">DecisionTree.jl&#39;s documentation</a></p><p>Hyperparameters:</p><ul><li><code>:num_iterations</code> =&gt; 7 (number of iterations of AdaBoost)</li></ul><p>Implements <code>fit!</code>, <code>transform!</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.DecisionTreeLearners.PrunedTree" href="#AMLPipelineBase.DecisionTreeLearners.PrunedTree"><code>AMLPipelineBase.DecisionTreeLearners.PrunedTree</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PrunedTree(
  Dict(
    :purity_threshold =&gt; 1.0,
    :max_depth =&gt; -1,
    :min_samples_leaf =&gt; 1,
    :min_samples_split =&gt; 2,
    :min_purity_increase =&gt; 0.0
  )
)</code></pre><p>Decision tree classifier.   See <a href="https://github.com/bensadeghi/DecisionTree.jl">DecisionTree.jl&#39;s documentation</a></p><p>Hyperparmeters:</p><ul><li><code>:purity_threshold</code> =&gt; 1.0 (merge leaves having &gt;=thresh combined purity)</li><li><code>:max_depth</code> =&gt; -1 (maximum depth of the decision tree)</li><li><code>:min_samples_leaf</code> =&gt; 1 (the minimum number of samples each leaf needs to have)</li><li><code>:min_samples_split</code> =&gt; 2 (the minimum number of samples in needed for a split)</li><li><code>:min_purity_increase</code> =&gt; 0.0 (minimum purity needed for a split)</li></ul><p>Implements <code>fit!</code>, <code>transform!</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.DecisionTreeLearners.RandomForest" href="#AMLPipelineBase.DecisionTreeLearners.RandomForest"><code>AMLPipelineBase.DecisionTreeLearners.RandomForest</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RandomForest(
  Dict(
    :output =&gt; :class,
    :num_subfeatures =&gt; 0,
    :num_trees =&gt; 10,
    :partial_sampling =&gt; 0.7,
    :max_depth =&gt; -1
  )
)</code></pre><p>Random forest classification.  See <a href="https://github.com/bensadeghi/DecisionTree.jl">DecisionTree.jl&#39;s documentation</a></p><p>Hyperparmeters:</p><ul><li><code>:num_subfeatures</code> =&gt; 0  (number of features to consider at random per split)</li><li><code>:num_trees</code> =&gt; 10 (number of trees to train)</li><li><code>:partial_sampling</code> =&gt; 0.7 (fraction of samples to train each tree on)</li><li><code>:max_depth</code> =&gt; -1 (maximum depth of the decision trees)</li><li><code>:min_samples_leaf</code> =&gt; 1 (the minimum number of samples each leaf needs to have)</li><li><code>:min_samples_split</code> =&gt; 2 (the minimum number of samples in needed for a split)</li><li><code>:min_purity_increase</code> =&gt; 0.0 (minimum purity needed for a split)</li></ul><p>Implements <code>fit!</code>, <code>transform!</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!-Tuple{Adaboost, DataFrames.DataFrame, Vector{T} where T}" href="#AMLPipelineBase.AbsTypes.fit!-Tuple{Adaboost, DataFrames.DataFrame, Vector{T} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(adaboost::Adaboost, features::DataFrame, labels::Vector)</code></pre><p>Optimize the hyperparameters of <code>Adaboost</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!-Tuple{PrunedTree, DataFrames.DataFrame, Vector{T} where T}" href="#AMLPipelineBase.AbsTypes.fit!-Tuple{PrunedTree, DataFrames.DataFrame, Vector{T} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(tree::PrunedTree, features::DataFrame, labels::Vector)</code></pre><p>Optimize the hyperparameters of <code>PrunedTree</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!-Tuple{RandomForest, DataFrames.DataFrame, Vector{T} where T}" href="#AMLPipelineBase.AbsTypes.fit!-Tuple{RandomForest, DataFrames.DataFrame, Vector{T} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(forest::RandomForest, features::DataFrame, labels::Vector)</code></pre><p>Optimize the parameters of the <code>RandomForest</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{Adaboost, DataFrames.DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{Adaboost, DataFrames.DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(adaboost::Adaboost, features::DataFrame)</code></pre><p>Predict using the optimized hyperparameters of the trained <code>Adaboost</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{PrunedTree, DataFrames.DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{PrunedTree, DataFrames.DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(ptree::PrunedTree, features::DataFrame)</code></pre><p>Predict using the optimized hyperparameters of the trained <code>PrunedTree</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{RandomForest, DataFrames.DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{RandomForest, DataFrames.DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(forest::RandomForest, features::DataFrame)</code></pre><p>Predict using the optimized hyperparameters of the trained <code>RandomForest</code> instance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.EnsembleMethods.BestLearner" href="#AMLPipelineBase.EnsembleMethods.BestLearner"><code>AMLPipelineBase.EnsembleMethods.BestLearner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BestLearner(
   Dict(
      # Output to train against
      # (:class).
      :output =&gt; :class,
      # Function to return partitions of instance indices.
      :partition_generator =&gt; (instances, labels) -&gt; kfold(size(instances, 1), 5),
      # Function that selects the best learner by index.
      # Arg learner_partition_scores is a (learner, partition) score matrix.
      :selection_function =&gt; (learner_partition_scores) -&gt; findmax(mean(learner_partition_scores, dims=2))[2],      
      # Score type returned by score() using respective output.
      :score_type =&gt; Real,
      # Candidate learners.
      :learners =&gt; [PrunedTree(), Adaboost(), RandomForest()],
      # Options grid for learners, to search through by BestLearner.
      # Format is [learner_1_options, learner_2_options, ...]
      # where learner_options is same as a learner&#39;s options but
      # with a list of values instead of scalar.
      :learner_options_grid =&gt; nothing
   )
)</code></pre><p>Selects best learner from the set by performing a  grid search on learners if grid option is indicated.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.EnsembleMethods.StackEnsemble" href="#AMLPipelineBase.EnsembleMethods.StackEnsemble"><code>AMLPipelineBase.EnsembleMethods.StackEnsemble</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">StackEnsemble(
   Dict(    
      # Output to train against
      # (:class).
      :output =&gt; :class,
      # Set of learners that produce feature space for stacker.
      :learners =&gt; [PrunedTree(), Adaboost(), RandomForest()],
      # Machine learner that trains on set of learners&#39; outputs.
      :stacker =&gt; RandomForest(),
      # Proportion of training set left to train stacker itself.
      :stacker_training_proportion =&gt; 0.3,
      # Provide original features on top of learner outputs to stacker.
      :keep_original_features =&gt; false
   )
)</code></pre><p>An ensemble where a &#39;stack&#39; of learners is used for training and prediction.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.EnsembleMethods.VoteEnsemble" href="#AMLPipelineBase.EnsembleMethods.VoteEnsemble"><code>AMLPipelineBase.EnsembleMethods.VoteEnsemble</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VoteEnsemble(
   Dict( 
      # Output to train against
      # (:class).
      :output =&gt; :class,
      # Learners in voting committee.
      :learners =&gt; [PrunedTree(), Adaboost(), RandomForest()]
   )
)</code></pre><p>Set of machine learners employing majority vote to decide prediction.</p><p>Implements: <code>fit!</code>, <code>transform!</code></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!-Tuple{BestLearner, DataFrames.DataFrame, Vector{T} where T}" href="#AMLPipelineBase.AbsTypes.fit!-Tuple{BestLearner, DataFrames.DataFrame, Vector{T} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(bls::BestLearner, instances::DataFrame, labels::Vector)</code></pre><p>Training phase:</p><ul><li>obtain learners as is if grid option is not present </li><li>generate learners if grid option is present </li><li>foreach prototype learner, generate learners with specific options found in grid</li><li>generate partitions</li><li>train each learner on each partition and obtain validation output</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!-Tuple{StackEnsemble, DataFrames.DataFrame, Vector{T} where T}" href="#AMLPipelineBase.AbsTypes.fit!-Tuple{StackEnsemble, DataFrames.DataFrame, Vector{T} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(se::StackEnsemble, instances::DataFrame, labels::Vector)</code></pre><p>Training phase of the stack of learners.</p><ul><li>perform holdout to obtain indices for </li><li>partition learner and stacker training sets</li><li>partition training set for learners and stacker</li><li>train all learners</li><li>train stacker on learners&#39; outputs</li><li>build final model from the trained learners</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.fit!-Tuple{VoteEnsemble, DataFrames.DataFrame, Vector{T} where T}" href="#AMLPipelineBase.AbsTypes.fit!-Tuple{VoteEnsemble, DataFrames.DataFrame, Vector{T} where T}"><code>AMLPipelineBase.AbsTypes.fit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">fit!(ve::VoteEnsemble, instances::DataFrame, labels::Vector)</code></pre><p>Training phase of the ensemble.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{BestLearner, DataFrames.DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{BestLearner, DataFrames.DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(bls::BestLearner, instances::DataFrame)</code></pre><p>Choose the best learner based on cross-validation results and use it for prediction.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{StackEnsemble, DataFrames.DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{StackEnsemble, DataFrames.DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(se::StackEnsemble, instances::DataFrame)</code></pre><p>Build stacker instances and predict</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.AbsTypes.transform!-Tuple{VoteEnsemble, DataFrames.DataFrame}" href="#AMLPipelineBase.AbsTypes.transform!-Tuple{VoteEnsemble, DataFrames.DataFrame}"><code>AMLPipelineBase.AbsTypes.transform!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transform!(ve::VoteEnsemble, instances::DataFrame)</code></pre><p>Prediction phase of the ensemble.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.FeatureSelectors.CatFeatureSelector" href="#AMLPipelineBase.FeatureSelectors.CatFeatureSelector"><code>AMLPipelineBase.FeatureSelectors.CatFeatureSelector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CatFeatureSelector(Dict(:name =&gt; &quot;catf&quot;))</code></pre><p>Automatically extract categorical columns based on  inferred element types.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.FeatureSelectors.CatNumDiscriminator" href="#AMLPipelineBase.FeatureSelectors.CatNumDiscriminator"><code>AMLPipelineBase.FeatureSelectors.CatNumDiscriminator</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CatNumDiscriminator(
   Dict(
      :name =&gt; &quot;catnumdisc&quot;,
      :maxcategories =&gt; 24
   )
)</code></pre><p>Transform numeric columns to string (as categories)  if the count of their unique elements &lt;= maxcategories.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.FeatureSelectors.CatNumDiscriminator-Tuple{Int64}" href="#AMLPipelineBase.FeatureSelectors.CatNumDiscriminator-Tuple{Int64}"><code>AMLPipelineBase.FeatureSelectors.CatNumDiscriminator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">CatNumDiscriminator(maxcat::Int)</code></pre><p>Helper function for CatNumDiscriminator.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.FeatureSelectors.FeatureSelector" href="#AMLPipelineBase.FeatureSelectors.FeatureSelector"><code>AMLPipelineBase.FeatureSelectors.FeatureSelector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FeatureSelector(
   Dict(
     :name =&gt; &quot;featureselector&quot;,
     :columns =&gt; [col1, col2, ...]
   )
)</code></pre><p>Returns a dataframe of the selected columns.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.FeatureSelectors.FeatureSelector-Tuple{Vararg{Int64, N} where N}" href="#AMLPipelineBase.FeatureSelectors.FeatureSelector-Tuple{Vararg{Int64, N} where N}"><code>AMLPipelineBase.FeatureSelectors.FeatureSelector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FeatureSelector(cols::Vararg{Int})</code></pre><p>Helper function for FeatureSelector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.FeatureSelectors.FeatureSelector-Tuple{Vector{Int64}}" href="#AMLPipelineBase.FeatureSelectors.FeatureSelector-Tuple{Vector{Int64}}"><code>AMLPipelineBase.FeatureSelectors.FeatureSelector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">FeatureSelector(cols::Vector{Int})</code></pre><p>Helper function for FeatureSelector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.FeatureSelectors.NumFeatureSelector" href="#AMLPipelineBase.FeatureSelectors.NumFeatureSelector"><code>AMLPipelineBase.FeatureSelectors.NumFeatureSelector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NumFeatureSelector(Dict(:name=&gt;&quot;numfeatsel&quot;))</code></pre><p>Automatically extracts numeric features based on their inferred element types.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.SKLearners.SKLearner" href="#AutoMLPipeline.SKLearners.SKLearner"><code>AutoMLPipeline.SKLearners.SKLearner</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SKLearner(learner::String, args::Dict=Dict())</code></pre><p>A Scikitlearn wrapper to load the different machine learning models. Invoking <code>sklearners()</code> will list the available learners. Please consult Scikitlearn documentation for arguments to pass.</p><p>Implements <code>fit!</code> and <code>transform!</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/c37956c47275a1fffcffc7405bfc670dae50252b/src/sklearners.jl#L93-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.SKLearners.sklearners-Tuple{}" href="#AutoMLPipeline.SKLearners.sklearners-Tuple{}"><code>AutoMLPipeline.SKLearners.sklearners</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">function sklearners()</code></pre><p>List the available scikitlearn machine learners.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/c37956c47275a1fffcffc7405bfc670dae50252b/src/sklearners.jl#L143-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AutoMLPipeline.SKPreprocessors.SKPreprocessor" href="#AutoMLPipeline.SKPreprocessors.SKPreprocessor"><code>AutoMLPipeline.SKPreprocessors.SKPreprocessor</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SKPreprocessor(preprocessor::String,args::Dict=Dict())</code></pre><p>A wrapper for Scikitlearn preprocessor functions.  Invoking <code>skpreprocessors()</code> will list the acceptable  and supported functions. Please check Scikitlearn documentation for arguments to pass.</p><p>Implements <code>fit!</code> and <code>transform!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/c37956c47275a1fffcffc7405bfc670dae50252b/src/skpreprocessor.jl#L95-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.CrossValidators.crossvalidate-Tuple{Machine, DataFrames.DataFrame, Vector{T} where T, String}" href="#AMLPipelineBase.CrossValidators.crossvalidate-Tuple{Machine, DataFrames.DataFrame, Vector{T} where T, String}"><code>AMLPipelineBase.CrossValidators.crossvalidate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">crossvalidate(pl::Machine,X::DataFrame,Y::Vector,sfunc::String=&quot;balanced_accuracy_score&quot;,nfolds=10)</code></pre><p>Runs K-fold cross-validation using balanced accuracy as the default. It support the  following metrics for classification:</p><ul><li>accuracy_score</li><li>balanced<em>accuracy</em>score</li><li>cohen<em>kappa</em>score</li><li>jaccard_score</li><li>matthews_corrcoef</li><li>hamming_loss</li><li>zero<em>one</em>loss</li><li>f1_score</li><li>precision_score</li><li>recall_score</li></ul><p>and the following metrics for regression:</p><ul><li>mean<em>squared</em>error</li><li>mean<em>squared</em>log_error</li><li>median<em>absolute</em>error</li><li>r2_score</li><li>max_error</li><li>explained<em>variance</em>score</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/IBM/AutoMLPipeline.jl/blob/c37956c47275a1fffcffc7405bfc670dae50252b/src/skcrossvalidator.jl#L65-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.Utils.aggregatorclskipmissing-Tuple{Function}" href="#AMLPipelineBase.Utils.aggregatorclskipmissing-Tuple{Function}"><code>AMLPipelineBase.Utils.aggregatorclskipmissing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">aggregatorclskipmissing(fn::Function)</code></pre><p>Function to create aggregator closure with skipmissing features</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.Utils.createmachine" href="#AMLPipelineBase.Utils.createmachine"><code>AMLPipelineBase.Utils.createmachine</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">createmachine(prototype::Machine, options=nothing)</code></pre><p>Create machine</p><ul><li><code>prototype</code>: prototype machine to base new machine on</li><li><code>args</code>: additional options to override prototype&#39;s options</li></ul><p>Returns: new machine</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.Utils.find_catnum_columns" href="#AMLPipelineBase.Utils.find_catnum_columns"><code>AMLPipelineBase.Utils.find_catnum_columns</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">find_catnum_columns(instances::DataFrame,maxuniqcat::Int=0)</code></pre><p>Finds all categorial and numerical columns. Categorical columns are those that do not have Real type nor do all their elements correspond to Real. Also, columns with size of unique instances are less than <code>maxuniqcat</code> are considered categorical.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.Utils.holdout-Tuple{Any, Any}" href="#AMLPipelineBase.Utils.holdout-Tuple{Any, Any}"><code>AMLPipelineBase.Utils.holdout</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">holdout(n, right_prop)</code></pre><p>Holdout method that partitions a collection into two partitions.</p><ul><li><code>n</code>: Size of collection to partition</li><li><code>right_prop</code>: Percentage of collection placed in right partition</li></ul><p>Returns: two partitions of indices, left and right</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.Utils.infer_eltype-Tuple{Vector{T} where T}" href="#AMLPipelineBase.Utils.infer_eltype-Tuple{Vector{T} where T}"><code>AMLPipelineBase.Utils.infer_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">infer_eltype(vector::Vector)</code></pre><p>Returns element type of vector unless it is Any. If Any, returns the most specific type that can be inferred from the vector elements.</p><ul><li><code>vector</code>: vector to infer element type on</li></ul><p>Returns: inferred element type</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.Utils.kfold-Tuple{Any, Any}" href="#AMLPipelineBase.Utils.kfold-Tuple{Any, Any}"><code>AMLPipelineBase.Utils.kfold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kfold(num_instances, num_partitions)</code></pre><p>Returns k-fold partitions.</p><ul><li><code>num_instances</code>: total number of instances</li><li><code>num_partitions</code>: number of partitions required</li></ul><p>Returns: training set partition.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.Utils.nested_dict_merge-Tuple{Dict, Dict}" href="#AMLPipelineBase.Utils.nested_dict_merge-Tuple{Dict, Dict}"><code>AMLPipelineBase.Utils.nested_dict_merge</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nested_dict_merge(first::Dict, second::Dict)</code></pre><p>Second nested dictionary is merged into first.</p><p>If a second dictionary&#39;s value as well as the first are both dictionaries, then a merge is conducted between the two inner dictionaries. Otherwise the second&#39;s value overrides the first.</p><ul><li><code>first</code>: first nested dictionary</li><li><code>second</code>: second nested dictionary</li></ul><p>Returns: merged nested dictionary</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.Utils.nested_dict_set!-Union{Tuple{T}, Tuple{Dict, Vector{T}, Any}} where T" href="#AMLPipelineBase.Utils.nested_dict_set!-Union{Tuple{T}, Tuple{Dict, Vector{T}, Any}} where T"><code>AMLPipelineBase.Utils.nested_dict_set!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nested_dict_set!(dict::Dict, keys::Array{T, 1}, value) where {T}</code></pre><p>Set value in a nested dictionary.</p><ul><li><code>dict</code>: nested dictionary to assign value</li><li><code>keys</code>: keys to access nested dictionaries in sequence</li><li><code>value</code>: value to assign</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.Utils.nested_dict_to_tuples-Tuple{Dict}" href="#AMLPipelineBase.Utils.nested_dict_to_tuples-Tuple{Dict}"><code>AMLPipelineBase.Utils.nested_dict_to_tuples</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">nested_dict_to_tuples(dict::Dict)</code></pre><p>Converts nested dictionary to list of tuples</p><ul><li><code>dict</code>: dictionary that can have other dictionaries as values</li></ul><p>Returns: list where elements are ([outer-key, inner-key, ...], value)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="AMLPipelineBase.Utils.score-Tuple{Symbol, Vector{T} where T, Vector{T} where T}" href="#AMLPipelineBase.Utils.score-Tuple{Symbol, Vector{T} where T, Vector{T} where T}"><code>AMLPipelineBase.Utils.score</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">score(metric::Symbol, actual::Vector, predicted::Vector)</code></pre><p>Score learner predictions against ground truth values.</p><p>Available metrics:</p><ul><li><p>:accuracy</p></li><li><p><code>metric</code>: metric to assess with</p></li><li><p><code>actual</code>: ground truth values</p></li><li><p><code>predicted</code>: predicted values</p></li></ul><p>Returns: score of learner</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/metaensembles/">« Meta-Ensembles</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.7 on <span class="colophon-date" title="Thursday 7 October 2021 08:24">Thursday 7 October 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
